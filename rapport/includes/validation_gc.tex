\subsection{Validation}
Dans cette partie nous expliquerons comment nous avons évalué le fonctionnement de notre ramasse-miette.

\paragraph{Monitoring de la mémoire}
À fin de d'analyser l'état de la mémoire nous avons crée une fonction d'affichage au sein de l'objet \emph{Gc} permettant de renvoyer l'état de la mémoire, c'est-à-dire quels sont les objets actuellement en mémoire et de savoir comment la taille du vecteur à évolué entre deux évaluations d'expressions. Le champ \emph{Usage} donne le nombre de \emph{Cell} utilisées actuellement par le programme, et les objets qui suivent sont les objets représentés par celles-ci, comme l'on voit dans la figure \ref{fig:mem}.

Nous avons également tracé les fuites mémoire dans l'execution via l'utilitaire valgrind.

\paragraph{Les fuites mémoires}
Il nous est apparu malgré la désallocation totale de cellules lors de la fermeture du programme via la primitive associée
\lstinline{void wipe_memory()}.
que des fuites étaient toujours présentes, ces différentes fuites sont dues à la partie lexer/parser et notamment à la fonction \lstinline{strdup()}.

Par manque de temps nous n'avons pas pu pousser notre compréhension sur l'allocation et la libération de la mémoire dans cette partie de l'interpréteur.
