\subsection{Environnement}

\paragraph{Rôle}
L'environnement permet de stocker les affectations de variables et la gestion
des variables locales comme celles créées par l'instruction \emph{let}. Il
convient de préciser que notre interprète est à liaison dynamique: les variables
nécessaires à l'exécution d'une fonction prennent leur valeur lors de l'exécution
même de la fonction, et non pas lors de sa déclaration.

\paragraph{Structures}
Afin de construire un environnement adapté à ces tâches, nous avons
décidé de créer deux nouvelles structures: la structure \emph{Link} et
la classe \emph{Cell\_Memory}, sur le modèle des autres cellules
telles que \emph{Cell\_Number} ou bien \emph{Cell\_Symbol}.

La classe \emph{Cell\_Memory} contient un nom de variable et
l'\emph{Object} qui lui est associé.  La structure \emph{Link}
contient tout simplement une \emph{Cell\_Memory} et un pointeur vers
un autre \emph{Link}.  L'environnement est donc construit comme une
liste chaînée de liaisons entre les noms de variables et leurs
valeurs.

Ainsi, la classe \emph{Environment} n'a besoin que de d'un pointeur
vers un \emph{Link}, nommé \emph{local} qui représente la tête de la
liste constituant l'environnement à tout moment, et d'une pile C++ de
pointeurs \emph{global} vers des \emph{Link}, qui permettent de
construire des environnements locaux.

Les structures sont représentées dans la figure \ref{fig:struct}.

\paragraph{Accès aux variables et affectations}
L'environnement fournit des méthodes pour que l'interprète puisse
accéder à la valeur associée à un certain nom de variable dans
l'environnement: \emph{get\_value}, et qu'il puisse ajouter des
liaisons à celui-ci: \emph{add\_bond}.

La fonction \emph{get\_value} renvoie la première valeur rencontrée dans la
liste chaînée associée au nom de variable donné en argument, on peut donc avoir
des phénomènes de masquage: deux valeurs peuvent être associées à un même nom de
variable, mais seul celle correspondant à l'affectation la plus récente pourra
être récupérée. La méthode \emph{add\_bond} déplace le pointeur \emph{local} sur
le nouveau \emph{Link} ajouté, afin que ce pointeur soit toujours à la tête de
la liste chaînée.

On peut voir quelques exemples d'affectations de variables dans la figure, et le
phénomène de masquage dans la figure \ref{fig:assign}.

\paragraph{Principe et intérêt des environnements locaux}
Les environnements locaux sont nécessaires dès que l'on veut appliquer
une \texttt{lambda} ou utiliser un \texttt{let}.

Les méthodes \emph{set\_global} et \emph{collapse} permettent de gérer
des affectations locales: \emph{set\_global} permet de sauvegarder le
pointeur \emph{local} correspondant à la tête courante de la liste
dans une pile. Ainsi avant toute entrée dans un environnement local,
il convient de faire un appel à cette méthode, nous permettant alors
de distinguer les affectations ayant été réalisées dans ce nouvel
environnement de celles ayant été réalisées précédemment. La méthode
\emph{collapse} permet ensuite de détruire toutes les affectations
réalisées entre le pointeur \emph{local} et le dernier pointeur
\emph{global} ajouté à la pile par \emph{set\_global}.

Finalement, la méthode \emph{wipe\_env} efface tout l'environnement.

Ceci est illustré dans la figure \ref{fig:local}.

\paragraph{Intérêt pour le garbage collector}
Le fonctionnement du garbage collector sera expliqué plus précisément
postérieurement.

Le fait de déclarer un nouveau type de cellules afin de créer
l'environnement permet dans le garbage collector de traiter les
\emph{Cell\_Memory} comme toute autre cellule représentant un objet
\texttt{Lisp}. De plus la mémoire allouée aux maillons de la liste
chaînée est désallouée lors de l'appel à \emph{collapse} ou
\emph{wipe\_env}.

Notre idée précédente consistait à réaliser une arborescence
d'environnements contenant chacun un vecteur de liaisons entre un nom
de variable et une valeur, et un pointeur vers l'environnement
immédiatement supérieur. Ainsi le \emph{Top Level} aurait un pointeur
nul, et tous les autres environnements pointeraient vers celui depuis
lequel ils ont été créés. Ce système permet une hiérarchisation des
environnements plus claire que le système finalement adopté, mais
était difficilement compatible avec notre projet de garbage collector
et l'idée a donc été délaissée.

Cette structure est représentée figure \ref{fig:old}.
